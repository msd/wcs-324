#include <iostream>#include <cmath>#include <chrono>#include <random>#include <thread>#include <mutex>#include <ratio>#include <utility>#include <fstream>#include <iterator>#include <memory>#include <map>#include <set>// GLM Core features#include <glm/vec2.hpp>#include <glm/vec3.hpp>// (GTC) Recommended GLM extensions#include <glm/gtc/matrix_transform.hpp>#include <glm/gtc/type_ptr.hpp>// (GTX) Eperimental GLM extensions#include <glm/gtx/string_cast.hpp>#include <GL/glew.h>#include <GL/freeglut.h>using glm::dvec2;using glm::dvec3;using glm::fvec2;using glm::fvec3;using glm::ivec2;// Materials found online at: http://devernay.free.fr/cours/opengl/materials.htmlstruct material_t{    // Ambient(RGB), Diffuse(RGB), Specular(RGB), Shininess    double ambr, ambg, ambb, difr, difg, difb, specr, specg, specb, shine;    void use() const    {        GLfloat mat[4];        mat[0] = ambr;        mat[1] = ambg;        mat[2] = ambb;        mat[3] = 1.0;        glMaterialfv(GL_FRONT, GL_AMBIENT, mat);        mat[0] = difr;        mat[1] = difg;        mat[2] = difb;        glMaterialfv(GL_FRONT, GL_DIFFUSE, mat);        mat[0] = specr;        mat[1] = specg;        mat[2] = specb;        glMaterialfv(GL_FRONT, GL_SPECULAR, mat);        glMaterialf(GL_FRONT, GL_SHININESS, shine * 128.0);    }};// Example for using with OpenGL:// Multiply the shininess by 128!//   mat[0] = ambr;//   mat[1] = ambg;//   mat[2] = ambb;//   mat[3] = 1.0;//   glMaterialfv(GL_FRONT, GL_AMBIENT, mat);//   mat[0] = difr;//   mat[1] = difg;//   mat[2] = difb;//   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat);//   mat[0] = specr;//   mat[1] = specg;//   mat[2] = specb;//   glMaterialfv(GL_FRONT, GL_SPECULAR, mat);//   glMaterialf(GL_FRONT, GL_SHININESS, shine * 128.0);constexpr material_tMATERIAL_BLUE           = { 0       , 0       , 0.43    , 0.26    , 0.24      , 0.67      , 0.32       ,  0.34      , 1         , 16.0 / 128.0   },MATERIAL_PURPLE         = { 0.6     , 0       , 0.62    , 0.31    , 0         , 0         ,  1         ,  1         , 1         , 41.0 / 128.0   },MATERIAL_EMERALD        = { 0.0215  , 0.1745  , 0.0215  , 0.07568 , 0.61424   , 0.07568   ,  0.633     ,  0.727811  , 0.633     , 0.6            },MATERIAL_JADE           = { 0.135   , 0.2225  , 0.1575  , 0.54    , 0.89      , 0.63      ,  0.316228  ,  0.316228  , 0.316228  , 0.1            },MATERIAL_OBSIDIAN       = { 0.05375 , 0.05    , 0.06625 , 0.18275 , 0.17      , 0.22525   ,  0.332741  ,  0.328634  , 0.346435  , 0.3            },MATERIAL_PEARL          = { 0.25    , 0.20725 , 0.20725 , 1       , 0.829     , 0.829     ,  0.296648  ,  0.296648  , 0.296648  , 0.088          },MATERIAL_RUBY           = { 0.1745  , 0.01175 , 0.01175 , 0.61424 , 0.04136   , 0.04136   ,  0.727811  ,  0.626959  , 0.626959  , 0.6            },MATERIAL_TURQUOISE      = { 0.1     , 0.18725 , 0.1745  , 0.396   , 0.74151   , 0.69102   ,  0.297254  ,  0.30829   , 0.306678  , 0.1            },MATERIAL_BRASS          = { 0.329412, 0.223529, 0.027451, 0.780392, 0.568627  , 0.113725  ,  0.992157  ,  0.941176  , 0.807843  , 0.21794872     },MATERIAL_BRONZE         = { 0.2125  , 0.1275  , 0.054   , 0.714   , 0.4284    , 0.18144   ,  0.393548  ,  0.271906  , 0.166721  , 0.2            },MATERIAL_CHROME         = { 0.25    , 0.25    , 0.25    , 0.4     , 0.4       , 0.4       ,  0.774597  ,  0.774597  , 0.774597  , 0.6            },MATERIAL_COPPER         = { 0.19125 , 0.0735  , 0.0225  , 0.7038  , 0.27048   , 0.0828    ,  0.256777  ,  0.137622  , 0.086014  , 0.1            },MATERIAL_GOLD           = { 0.24725 , 0.1995  , 0.0745  , 0.75164 , 0.60648   , 0.22648   ,  0.628281  ,  0.555802  , 0.366065  , 0.4            },MATERIAL_SILVER         = { 0.19225 , 0.19225 , 0.19225 , 0.50754 , 0.50754   , 0.50754   ,  0.508273  ,  0.508273  , 0.508273  , 0.4            },MATERIAL_BLACK_PLASTIC  = { 0.0     , 0.0     , 0.0     , 0.01    , 0.01      , 0.01      ,  0.50      ,  0.50      , 0.50      , .25            },MATERIAL_CYAN_PLASTIC   = { 0.0     , 0.1     , 0.06    , 0.0     , 0.50980392, 0.50980392,  0.50196078,  0.50196078, 0.50196078, .25            },MATERIAL_GREEN_PLASTIC  = { 0.0     , 0.0     , 0.0     , 0.1     , 0.35      , 0.1       ,  0.45      ,  0.55      , 0.45      , .25            },MATERIAL_RED_PLASTIC    = { 0.0     , 0.0     , 0.0     , 0.5     , 0.0       , 0.0       ,  0.7       ,  0.6       , 0.6       , .25            },MATERIAL_WHITE_PLASTIC  = { 0.0     , 0.0     , 0.0     , 0.55    , 0.55      , 0.55      ,  0.70      ,  0.70      , 0.70      , .25            },MATERIAL_YELLOW_PLASTIC = { 0.0     , 0.0     , 0.0     , 0.5     , 0.5       , 0.0       ,  0.60      ,  0.60      , 0.50      , .25            },MATERIAL_BLACK_RUBBER   = { 0.02    , 0.02    , 0.02    , 0.01    , 0.01      , 0.01      ,  0.4       ,  0.4       , 0.4       , .078125        },MATERIAL_CYAN_RUBBER    = { 0.0     , 0.05    , 0.05    , 0.4     , 0.5       , 0.5       ,  0.04      ,  0.7       , 0.7       , .078125        },MATERIAL_GREEN_RUBBER   = { 0.0     , 0.05    , 0.0     , 0.4     , 0.5       , 0.4       ,  0.04      ,  0.7       , 0.04      , .078125        },MATERIAL_RED_RUBBER     = { 0.05    , 0.0     , 0.0     , 0.5     , 0.4       , 0.4       ,  0.7       ,  0.04      , 0.04      , .078125        },MATERIAL_WHITE_RUBBER   = { 0.05    , 0.05    , 0.05    , 0.5     , 0.5       , 0.5       ,  0.7       ,  0.7       , 0.7       , .078125        },MATERIAL_YELLOW_RUBBER  = { 0.05    , 0.05    , 0.0     , 0.5     , 0.5       , 0.4       ,  0.7       ,  0.7       , 0.04      , .078125        };std::unique_ptr<material_t> DEFAULT_MATERIAL = nullptr;void set_default_material(){    GLfloat default_amb[4], default_dif[4], default_spec[4], default_shine;    glGetMaterialfv(GL_FRONT, GL_AMBIENT, default_amb);    glGetMaterialfv(GL_FRONT, GL_DIFFUSE, default_dif);    glGetMaterialfv(GL_FRONT, GL_SPECULAR, default_spec);    glGetMaterialfv(GL_FRONT, GL_SHININESS, &default_shine);    DEFAULT_MATERIAL = std::unique_ptr<material_t>(new material_t{        static_cast<double>(default_amb[0]),        static_cast<double>(default_amb[1]),        static_cast<double>(default_amb[2]),        static_cast<double>(default_dif[0]),        static_cast<double>(default_dif[1]),        static_cast<double>(default_dif[2]),        static_cast<double>(default_spec[0]),        static_cast<double>(default_spec[1]),        static_cast<double>(default_spec[2]),        static_cast<double>(default_shine)}    );}/// Window constantsconstexpr size_t   WIN_WIDTH  = 900;constexpr size_t   WIN_HEIGHT = 900;const std::string  WIN_TITLE  = "Tetris knock-off";constexpr GLdouble BG_COLOR[] = { 23 / 255.0, 24 / 255.0, 20 / 255.0 };/// Color constantsconstexpr GLfloat GRID_BORDER_COLOR[] = { 0, 1, 0, 1 };/// Game constantsconstexpr int FPS = 120;/// Other constantsconstexpr char ASCII_ESCAPE        = 27;constexpr int  CIRCLE_SLICES       = 20;constexpr int  FRAME_PERIOD_MILLIS = 1000.0 / FPS;constexpr GLfloat    GRID_UNIT_SIZE = 1,  /* The width of a square of the grid */    GRID_X         = 10, /* X-coord of the bottom-left point */    GRID_Y         = 5,  /* Y-coord of bottom-left point */    GRID_WIDTH     = 9,  /* How many units accross the last position on the grid is from the first position */    GRID_HEIGHT    = 19; /* How many units over the last position on the grid is from the first position */// from "OpenGL Programming Guide" 6/e (1997)const GLfloat// sphere_shininess[] = { 50.0 },// sphere_specular[] = {1, 1, 1, 1},    light_position[] = { 1, 1, 1, 0 },    white_light[]    = { 1, 1, 1, 1 },    lmodel_ambient[] = { 0.1, 0.1, 0.1, 1 };auto irand = std::mt19937_64(std::chrono::system_clock::now().time_since_epoch().count());double drand(){    return irand() / static_cast<double>(irand.max());}double dnrand(){    return (irand() % 2 ? 1.0 : -1.0) * drand();}void write_text_centered(float world_x, float world_y, float scale, std::string txt){    glPushMatrix();    glTranslatef(        world_x - scale * glutStrokeLengthf(GLUT_STROKE_ROMAN, reinterpret_cast<const unsigned char*>(txt.c_str())) / 2.f,        world_y  - scale * glutStrokeHeight(GLUT_STROKE_ROMAN) / 2.f, 0);    glScalef(scale, scale, 1);    glutStrokeString(GLUT_STROKE_ROMAN, reinterpret_cast<const unsigned char*>(txt.c_str()));    glPopMatrix();}struct CircleDrawer{private:    GLuint display_list;public:    double radius;    CircleDrawer(double radius, int slices, int stacks) : radius(radius)    {        display_list = glGenLists(1);        glNewList(display_list, GL_COMPILE);        // draw_circle(radius, resolution);        glutSolidSphere(radius, slices, stacks);        // glutWireSphere(radius, 20, 20);        glEndList();    }    void draw()    {        glCallList(display_list);    }};struct Boxf{    GLfloat top, right, bottom, left;    auto width()    {        return right - left;    }    auto height()    {        return top - bottom;    }    std::string to_string()    {        using std::to_string;        return "<Boxf TOP=" + to_string(top) + ", RIGHT=" + to_string(right)               + ", BOTTOM=" + to_string(bottom) + ", LEFT=" + to_string(left) + '>';    }};class Tile;class Game;struct Color{    double r, g, b;};/** * Stores similar (same radius) circles and provides facilities for drawing * for drawing them efficiently. */struct TileList{    CircleDrawer               display_list{ 1, 1, 1 };    Game *parent;    double                     radius;    std::map<int, std::weak_ptr<Tile>> the_tiles;    // Initialises    TileList(Game *parent, double radius, int slices) : parent(parent), radius(radius)    {        display_list = CircleDrawer(radius, slices, slices);    }    std::vector<std::shared_ptr<Tile>> add_circles_with_color(int n, const material_t& m)    {        std::vector<std::shared_ptr<Tile>> tbr;        for (int i = 0; i < n; ++i)        {            tbr.push_back(add_circle_with_color(m));        }        return tbr;    }    std::shared_ptr<Tile> add_circle_with_color(const material_t& m)    {        auto id = generate_new_id();        auto spt = std::make_shared<Tile>(id, m);        the_tiles[id] = std::weak_ptr(spt);        return spt;    }    void draw_all();private:    int generate_new_id()    {        while (1)        {            int id = irand() % 4096;            if (!the_tiles.count(id))            {                return id;            }        }    }};void reshape(int w, int h){    glViewport(0, 0, w, h);    glMatrixMode(GL_PROJECTION);    glLoadIdentity();    glOrtho(0, 30, 0, 30, 0.01, 20);    glMatrixMode(GL_MODELVIEW);}struct AnimationRunnable;/** Class to workaround GLUT's limitations, requiring static functions. * Faciliates pausing and shceduling the animation loop of the seclected * Game class. */class Animation{    static bool in_loop, should_loop;    static std::mutex loop_mutex;    static AnimationRunnable *current_instance;public:    static auto get_current_instance()    {        return current_instance;    }    static void set_current_instance(AnimationRunnable *instance)    {        current_instance = instance;    }    static void loop(int);    static bool running()    {        return should_loop;    }    /** Stops the animation loop from executing another iteration */    static void pause()    {        should_loop = false;    }    static void resume()    {        const std::scoped_lock<std::mutex> lock(loop_mutex);        if (!in_loop)        {            glutTimerFunc(0, &Animation::loop, 0);        }        should_loop = true;    }};struct AnimationRunnable{    friend void Animation::loop(int);    /** The function that will be called by the Animation class */    virtual void animation_iteration() = 0;};enum class tetromino_type: uint8_t{    I_PIECE,    O_PIECE,    T_PIECE,    S_PIECE,    Z_PIECE,    J_PIECE,    L_PIECE,};tetromino_type random_tetromino_type(){    switch (irand() % 7)    {    case 0:        return tetromino_type::I_PIECE;    case 1:        return tetromino_type::O_PIECE;    case 2:        return tetromino_type::S_PIECE;    case 3:        return tetromino_type::T_PIECE;    case 4:        return tetromino_type::Z_PIECE;    case 5:        return tetromino_type::J_PIECE;    default:        return tetromino_type::L_PIECE;    }}// Colours as specified in https://harddrop.com/wiki/Tetris_Guidelinestatic std::map<tetromino_type, Color> tetromino_colours ={    { tetromino_type::I_PIECE, { 0,   1, 1 } }, // Cyan I    { tetromino_type::O_PIECE, { 1,   1, 0 } }, // Yellow O    { tetromino_type::T_PIECE, { 1,   0, 1 } }, // Purple T    { tetromino_type::S_PIECE, { 0,   1, 0 } }, // Green S    { tetromino_type::Z_PIECE, { 1,   0, 0 } }, // Red Z    { tetromino_type::J_PIECE, { 0,   0, 1 } }, // Blue J    { tetromino_type::L_PIECE, { 1, 0.5, 0 } }, // Orange L};tetromino_type get_next_type(){    return random_tetromino_type();//    return tetromino_type::O_PIECE;}static std::map<tetromino_type, material_t> tetromino_materials = {    { tetromino_type::I_PIECE, MATERIAL_CYAN_PLASTIC }, // Cyan I    { tetromino_type::O_PIECE, MATERIAL_GOLD   },      // Yellow O    { tetromino_type::T_PIECE, MATERIAL_PURPLE },      // Purple T    { tetromino_type::S_PIECE, MATERIAL_EMERALD},      // Green S    { tetromino_type::Z_PIECE, MATERIAL_RUBY   },      // Red Z    { tetromino_type::J_PIECE, MATERIAL_BLUE   },      // Blue J    { tetromino_type::L_PIECE, MATERIAL_COPPER },      // Orange L};class Tile{    Game *parent;    int tile_id;    ivec2 position;public:    material_t material;    Tile(int tile_id, material_t material);    void set_position(ivec2 p)    {        position = p;    }    void set_position(int x, int y)    {        position = {x, y};    }    auto get_position()    {        return position;    }};/** * Class that handles a falling tetromino and all its associated * tiles. Onces the piece settles all its tiles are transferred * to the parent Game instance. */class Tetromino{    Game *parent;    /**     * Position of "origin" tile of this tetromino in grid coords.     * All tiles are placed relative to this position.     */    ivec2 origin_grid_position();    int orientation = 0; // valid values 0-3 (inclusive)    std::vector<ivec2> tile_piece_origin_positions();    bool is_touching_left_border(const Boxf &boundaries);    bool is_touching_right_border(const Boxf &boundaries);    bool is_touching_bottom_border(const Boxf &boundaries);    void unconditional_move_left();    void unconditional_move_right();    void unconditional_move_down();    std::vector<std::shared_ptr<Tile>> tetromino_tiles;public:    std::vector<std::shared_ptr<Tile>> strip_tiles();    bool rotate_srs_clockwise();    std::vector<ivec2> tile_grid_positions;    tetromino_type ttype;    Tetromino(Game *parent, tetromino_type ttype);    void rotate_clockwise();    void position_tiles();    bool move_down_if_possible();    bool move_right_if_possible();    bool move_left_if_possible();};/** * Positions of tiles around the origin point as depicted in * https://web.archive.org/web/20210125143800/http://harddrop.com/w/images/1/17/SRS-true-rotations.png * Each tetromino's origin is depicted the above link * and around brackets in the following table: * *   *--------*------------ * *   | O:       | I:         \ *   |  2  3    | 1 (0) 2 3  / *   | (0) 1    |            \ *   |          |            / *   *----------*-----------*---------* *   | T:       | S:        | Z:      | *   |    3     |    2  3   | 2  3    | *   | 1 (0) 2  | 1 (0)     |   (0) 1 | *   |          |           |         | *   *----------*-----------*---------* *   | L:       | J:       / *   |       3  | 3        \ *   | 1 (0) 2  | 1 (0) 2  / *   |          |          \ *   *----------*-----------* * * These positions show how the tetromino is as it spawns so e.g. for * the I piece would be horizontal and the T piece flat-side down.  */std::map<tetromino_type, std::vector<ivec2>> tetromino_tile_positions = {    { tetromino_type::I_PIECE, { {0, 0}, {-1, 0}, {1, 0}, {2, 0} } },    { tetromino_type::O_PIECE, { {0, 0}, {1, 0},  {0, 1}, {1, 1} } },    { tetromino_type::T_PIECE, { {0, 0}, {-1, 0}, {1, 0}, {0, 1} } },    { tetromino_type::S_PIECE, { {0, 0}, {-1, 0}, {0, 1}, {1, 1} } },    { tetromino_type::Z_PIECE, { {0, 0}, {1, 0},  {-1, 1},{0, 1} } },    { tetromino_type::J_PIECE, { {0, 0}, {-1, 0}, {1, 0}, {-1, 1}} },    { tetromino_type::L_PIECE, { {0, 0}, {-1, 0}, {1, 0}, {1, 1} } },};/** * Performs orthogonal rotations on the points given. The rotation * performed is based on the rotation matrix: * ((cos a, -sin a), (sin a, cos a)) where a = -r*90 degrees. * @param[points] the points to rotate * @param[orientation] the number of 90-degree clockwise rotations to perform. *                     If negative then counter-clockwise rotations will be *                     performed. * @returns the positions of the tetromino rotated. */std::vector<ivec2> pure_rotation(std::vector<ivec2> points, int r){    if (r < 0)    {        // counter clockwise        int n = (-r) % 4;        for (int i = 0; i < n; ++i)        {            for (auto &pos: points)            {                pos = {pos.y, -pos.x};            }        }    }    else    {        // clockwise        int n = r % 4;        for (int i = 0; i < n; ++i)        {            for (auto &pos: points)            {                pos = {pos.y, -pos.x};            }        }    }    return points;}/** Offeset data as specified in * https://web.archive.org/web/20201112015205/https://harddrop.com/wiki/SRS#How_Guideline_SRS_Really_Works */std::map<std::pair<tetromino_type, int>, std::vector<ivec2>> tetromino_offset_data ={    {{tetromino_type::J_PIECE, 0}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::J_PIECE, 1}, {{0, 0}, {+1, 0}, {+1,-1}, {0,+2}, {+1,+2}}},    {{tetromino_type::J_PIECE, 2}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::J_PIECE, 3}, {{0, 0}, {-1, 0}, {-1,-1}, {0,+2}, {-1,+2}}},    {{tetromino_type::L_PIECE, 0}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::L_PIECE, 1}, {{0, 0}, {+1, 0}, {+1,-1}, {0,+2}, {+1,+2}}},    {{tetromino_type::L_PIECE, 2}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::L_PIECE, 3}, {{0, 0}, {-1, 0}, {-1,-1}, {0,+2}, {-1,+2}}},    {{tetromino_type::S_PIECE, 0}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::S_PIECE, 1}, {{0, 0}, {+1, 0}, {+1,-1}, {0,+2}, {+1,+2}}},    {{tetromino_type::S_PIECE, 2}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::S_PIECE, 3}, {{0, 0}, {-1, 0}, {-1,-1}, {0,+2}, {-1,+2}}},    {{tetromino_type::T_PIECE, 0}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::T_PIECE, 1}, {{0, 0}, {+1, 0}, {+1,-1}, {0,+2}, {+1,+2}}},    {{tetromino_type::T_PIECE, 2}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::T_PIECE, 3}, {{0, 0}, {-1, 0}, {-1,-1}, {0,+2}, {-1,+2}}},    {{tetromino_type::Z_PIECE, 0}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::Z_PIECE, 1}, {{0, 0}, {+1, 0}, {+1,-1}, {0,+2}, {+1,+2}}},    {{tetromino_type::Z_PIECE, 2}, {{0, 0}, { 0, 0}, { 0, 0}, {0, 0}, { 0, 0}}},    {{tetromino_type::Z_PIECE, 3}, {{0, 0}, {-1, 0}, {-1,-1}, {0,+2}, {-1,+2}}},    {{tetromino_type::I_PIECE, 0}, {{ 0, 0}, {-1, 0}, {+2, 0}, {-1, 0}, {+2, 0}}},    {{tetromino_type::I_PIECE, 1}, {{-1, 0}, { 0, 0}, { 0, 0}, { 0,+1}, { 0,-2}}},    {{tetromino_type::I_PIECE, 2}, {{-1,+1}, {+1,+1}, {-2,+1}, {+1, 0}, {-2, 0}}},    {{tetromino_type::I_PIECE, 3}, {{ 0,+1}, { 0,+1}, { 0,+1}, { 0,-1}, { 0,+2}}},    {{tetromino_type::O_PIECE, 0}, {{ 0, 0}}},    {{tetromino_type::O_PIECE, 1}, {{ 0,-1}}},    {{tetromino_type::O_PIECE, 2}, {{-1,-1}}},    {{tetromino_type::O_PIECE, 3}, {{-1, 0}}},};class Game: public AnimationRunnable{    bool game_over = false;    float score = 0;    int lines_erased = 0;    int level = 1;    GLfloat sq; /* width of a unit square on the grid in world coordinates */    GLuint border_display_list = 0;    Boxf        grid,           /**< the position of the grid in world coordinates */        border;         /**< border position in world coordinates */    std::chrono::time_point<std::chrono::system_clock> time_last_move = std::chrono::system_clock::now();    std::unique_ptr<Tetromino> falling_tetromino = nullptr;    std::vector<std::shared_ptr<Tile> > settled_tiles;    std::vector<GLfloat> x_grid_positions, y_grid_positions;    void make_border_list()    {        GLfloat vertices[4][2] = {            { border.left,  border.bottom }, // bottom left            { border.left,  border.top    }, // top left            { border.right, border.top    }, // top right            { border.right, border.bottom }, // bottom right        };        border_display_list = glGenLists(1);        glNewList(border_display_list, GL_COMPILE);        DEFAULT_MATERIAL->use();        glColor4fv(GRID_BORDER_COLOR);        glBegin(GL_LINES);        glNormal3f(0, 0, 1);        glVertex2fv(vertices[0]);        glVertex2fv(vertices[1]);        glVertex2fv(vertices[1]);        glVertex2fv(vertices[2]);        glVertex2fv(vertices[2]);        glVertex2fv(vertices[3]);        glVertex2fv(vertices[3]);        glVertex2fv(vertices[0]);        glEnd();        glEndList();    }    /** Remove all tiles from that line. */    void remove_at_line(int grid_y)    {        auto ti = settled_tiles.begin();        while (ti != settled_tiles.end())        {            if ((*ti)->get_position().y == grid_y)            {                ti = settled_tiles.erase(ti);            }            else            {                ti++;            }        }    }    /** translating all the tiles that lie above the line     * that will be removed, simulate falling     */    void handle_fall_above_line(int grid_y)    {        auto ti = std::begin(settled_tiles);        while (ti != std::end(settled_tiles))        {            auto tpos = (*ti)->get_position();            if (tpos.y > grid_y)            {                tpos.y -= 1;                (*ti)->set_position(tpos);            }            ++ti;        }    }    /// Take ownership of tiles owned by Tetromino    void settle_falling()    {        for (auto &tile: falling_tetromino->strip_tiles())        {            settled_tiles.push_back(std::move(tile));        }    }    auto grid_xs()    {        return x_grid_positions;    }    auto grid_ys()    {        return y_grid_positions;    }    void level_up()    {        ++level;    }    void increase_score(float inc)    {        score += inc;        if (score > 5 * level)        {            level_up();        }    }    void handle_full_lines()    {        auto fys = filled_lines();        if (!fys.size()) // No lines are full        {            return;        }        lines_erased += fys.size();        int points_earned;        switch (lines_erased)        {        case 1:            points_earned = 1;            break;        case 2:            points_earned = 3;            break;        case 3:            points_earned = 5;            break;        default:            points_earned = 8;        }        increase_score(points_earned);        auto gys = grid_ys();        // Starting from the top of the grid going downwards the lines are checked.        for (auto gyi = std::crbegin(gys); gyi != std::crend(gys); ++gyi)        {            if (fys.count(*gyi)) // is line filled?            {                remove_at_line(*gyi);                handle_fall_above_line(*gyi);            }        }    }    std::chrono::duration<double> piece_fall_period()    {        return std::chrono::duration<double>(pow(0.8 - (level - 1) * 0.007, level - 1));    }    // This function is not called directly but instead from the Animation class    // that exclusively handles animation.    virtual void animation_iteration()    {        if (!game_over)        {            if (std::chrono::system_clock::now() - time_last_move > piece_fall_period()) // time for next move?            {                bool move_succeeded = falling_tetromino->move_down_if_possible();                if (!move_succeeded) // falling tetromino has reached bottom                {                    std::cout << "Reached bottom" << std::endl;                    settle_falling(); // Stops tiles from falling                    handle_full_lines(); // Erases lines that are full and drops the tiles from lines above                    new_falling_piece(); // Creates a new tetromino                }                time_last_move = std::chrono::system_clock::now();            }        }        else        {            stop_animation();        }    }    void new_falling_piece()    {        tetromino_type next_type = get_next_type();        falling_tetromino = std::make_unique<Tetromino>(this, next_type);        if (!are_positions_empty(falling_tetromino->tile_grid_positions))        {            game_over = true;            stop_animation();        }    }public:    bool is_touching_left_border(std::vector<ivec2>);    bool is_touching_right_border(std::vector<ivec2>);    bool is_touching_bottom_border(std::vector<ivec2>);    void attempt_rotate()    {        falling_tetromino->rotate_srs_clockwise();    }    std::vector<ivec2> used_tiles()    {        auto tbr = std::vector<ivec2>();        for (auto &tile: settled_tiles)        {            tbr.push_back(tile->get_position());        }        std::cout << "[INFO] Total used tiles: " << tbr.size() << std::endl;        return tbr;    }    bool is_position_empty(const ivec2 &grid_pos)    {        auto v = used_tiles();        return std::find(v.begin(), v.end(), grid_pos) == v.end();    }    /**     * Checks if positons are within the grid bounds and are empty     * Returns true the positions are both within the grid bounds     * and if all are empty.     * @param[gpositions] the grid positions to be checked     * @returns true if all positions are valid, false otherwise     */    bool are_positions_valid(const std::vector<ivec2> &gpositions)    {        return are_positions_within_grid_bounds(gpositions)            && are_positions_empty(gpositions);    }    bool are_positions_within_grid_bounds(const std::vector<ivec2> &gpositions)    {        for (const auto &pos: gpositions)        {            if (pos.x > grid_positions.right || pos.x < grid_positions.left || pos.y < grid_positions.bottom)            {                return false;            }        }        return true;    }    /**     * Checks the positions are all empty, i.e. not already occupied     * by one of the settled tiles.     * @param[gpositions] the grid positions to be checked if are empty     * @returns true if all the positions passed are not occupied     */    bool are_positions_empty(const std::vector<ivec2> &gpositions)    {        auto v = used_tiles();        for (auto &grid_pos: gpositions)        {            if (std::find(v.begin(), v.end(), grid_pos) != v.end())            {                return false;            }        }        return true;    }    void attempt_move_left()    {        falling_tetromino->move_left_if_possible();    }    void attempt_move_right()    {        falling_tetromino->move_right_if_possible();    }    void attempt_move_down()    {        if (falling_tetromino->move_down_if_possible())        {            increase_score(0.1);        }    }    dvec2 grid_to_world(float grid_x, float grid_y)    {        return { grid.left + grid_x / sq, grid.bottom + grid_y / sq };    }    fvec2 grid_to_world(const fvec2& p)    {        return { grid.left + p.x / sq, grid.bottom + p.y / sq };    }    std::unique_ptr<TileList> tiles = nullptr;    Boxf grid_positions; /* the legal positions on the grid. left <= x <= right, bottom <= y <= top */    void start_animation()    {        Animation::set_current_instance(this);        Animation::resume();    }    /** Stops the animation loop from running. */    void stop_animation()    {        if (Animation::get_current_instance() == this)        {            Animation::pause();        }    }    /** Returns true if the animation is running for this game instance.     * If this instance is not selected then it is false.     */    bool animation_running()    {        if (Animation::get_current_instance() == this)        {            return Animation::running();        }        return false;    }    /**     * Returns the grid y coord of lines that are full (horizontally),     * in no particular order     */    std::set<int> filled_lines()    {        // Put the settled tiles in buckets based on y-coordinate (on grid)        std::map<int, std::set<int>> lines;        for (auto &gpos: used_tiles())        {            if (!lines.count(gpos.y))            {                lines[gpos.y] = std::set<int>();            }            lines[gpos.y].insert(gpos.x);        }        //        std::set<int> filled_line_ys;        for (auto &p: lines)        {            auto line_y = p.first;            auto line_xs = p.second;            bool line_is_complete = true;            for (auto x: grid_xs())            {                if (!line_xs.count(x))                {                    line_is_complete = false;                    break;                }            }            if (line_is_complete)            {                filled_line_ys.insert(line_y);            }        }        return filled_line_ys;    }    Game(GLfloat x, GLfloat y, GLfloat w, GLfloat h, GLfloat sq) : sq(sq)    {        std::cout << "START GRID CONSTRUCTOR BOXES\n";        grid           = { y + h * sq, x + w * sq, y, x };        grid_positions = { h, w, 0, 0 };        border         = {            grid.top + sq / 2.0f + .1f,            grid.right + sq / 2.0f + .1f,            grid.bottom - sq / 2.0f - .1f,            grid.left - sq / 2.0f - .1f        };        std::cout << "GRID = " << grid.to_string() << '\n'                  << "GRID POSITIONS = " << grid_positions.to_string() << '\n'                  << "BORDER = " << border.to_string() << '\n'                  << "END GRID CONSTRUCTOR BOXES" << std::endl;        tiles = std::make_unique<TileList>(this, sq / 2.0f, CIRCLE_SLICES);        make_border_list();        for (auto i = grid_positions.left; i <= grid_positions.right; i += sq)        {            x_grid_positions.push_back(i);        }        for (auto i = grid_positions.bottom; i <= grid_positions.top; i += sq)        {            y_grid_positions.push_back(i);        }        new_falling_piece();    }    ~Game()    {        glDeleteLists(border_display_list, 1);        border_display_list = 0;        std::cerr << "INFO: !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! DELETED GAME !!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;    }    void draw_score()    {        glPushMatrix();        glColor3f(1,1,1);        glTranslatef(2, 15, 0);        glScalef(0.005, 0.005, 1);        std::string score_str = "Score " + std::to_string((int)score);        glutStrokeString(GLUT_STROKE_ROMAN, reinterpret_cast<const unsigned char*>(score_str.c_str()));        glPopMatrix();    }    void draw_level_title()    {        std::string level_str = "Level " + std::to_string(level);        auto horizontal_midpoint = (grid.left + grid.right) / 2.f;        write_text_centered(horizontal_midpoint, grid.top + 2, 0.01, level_str);    }    void draw_ui()    {        draw_score();        draw_level_title();    }    void draw_game_over()    {        write_text_centered(15, 15, 0.03, "GAME OVER");        write_text_centered(15, 10, 0.01, ":(");        write_text_centered(15, 5, 0.005, "Restart the game to play again");    }    void draw_all()    {        // draws the tiles        if (game_over)        {            draw_game_over();        }        else if (animation_running())        {            tiles->draw_all();            draw_border();            draw_ui();        }        else        {            draw_pause_screen();        }    }    void draw_pause_screen()    {        write_text_centered(15, 15, 0.04, "PAUSED");        write_text_centered(15, 11, 0.01, "PRESS SPACE TO RESUME");    }    void draw_border()    {        if (border_display_list)        {            glCallList(border_display_list);        }        else        {            std::cout << "WARNING: border draw list not initialized" << std::endl;        }    }};void TileList::draw_all()    {        std::vector<std::map<int, std::weak_ptr<Tile>>::iterator> to_be_removed;        for (auto i = the_tiles.begin(); i != the_tiles.end(); ++i)        {            auto spt = i->second.lock();            if (!spt)            {                to_be_removed.push_back(i);                continue;            }            auto pos = parent->grid_to_world(spt->get_position());            glPushMatrix();            glTranslatef(pos.x, pos.y, 0);            spt->material.use();            display_list.draw();            glPopMatrix();        }        for (auto i = to_be_removed.rbegin(); i != to_be_removed.rend(); ++i)        {            the_tiles.erase(*i);        }    }Tile::Tile(int tile_id, material_t material) : tile_id(tile_id), material(material) {}std::vector<std::shared_ptr<Tile>> Tetromino::strip_tiles(){    return std::move(tetromino_tiles);}std::vector<ivec2> translate_all(std::vector<ivec2> vs, ivec2 t){    std::for_each(std::begin(vs), std::end(vs), [&](ivec2 &v){ v += t; });    return vs;}Tetromino::Tetromino(Game *parent, tetromino_type ttype) : parent(parent), ttype(ttype){    if (!tetromino_tile_positions.count(ttype))    {        std::cerr << "Tetromino type given invalid" << std::endl;    }    auto origin_gpos = ivec2{ 4, parent->grid_positions.top - (tetromino_type::I_PIECE == ttype?0:1) };    tile_grid_positions = translate_all(tetromino_tile_positions[ttype], origin_gpos);    auto m = tetromino_materials[ttype];    for (auto p: parent->tiles->add_circles_with_color(4, m))    {        tetromino_tiles.push_back(std::move(p));    }    position_tiles();}/** * Returns true if the move right was successful */bool Tetromino::move_right_if_possible(){    if (parent->is_touching_right_border(tile_grid_positions))    {        return false;    }    auto new_tile_positions = translate_all(tile_grid_positions, {1, 0});    if (!parent->are_positions_empty(new_tile_positions))    {        return false;    }    unconditional_move_right();    return true;}bool Tetromino::move_down_if_possible(){    if (parent->is_touching_bottom_border(tile_grid_positions))    {        return false;    }    auto new_tile_grid_positions = translate_all(tile_grid_positions, {0, -1});    if (!parent->are_positions_empty(new_tile_grid_positions))    {        return false;    }    unconditional_move_down();    return true;}/** * Returns true if the move left was successful */bool Tetromino::move_left_if_possible(){    if (parent->is_touching_left_border(tile_grid_positions))    {        return false;    }    auto new_tile_grid_positions = translate_all(tile_grid_positions, {-1, 0});    if (!parent->are_positions_empty(new_tile_grid_positions))    {        return false;    }    unconditional_move_left();    return true;}bool Game::is_touching_left_border(std::vector<ivec2> vp){//    for (auto tile_pos: tile_grid_positions())//    {//        if (tile_pos.x <= boundaries.left)//        {//            return true;//        }//    }//    return false;    return std::any_of(std::begin(vp), std::end(vp), [&grid_positions = this->grid_positions](const auto &p)    {        return p.x <= grid_positions.left;    });}bool Game::is_touching_right_border(std::vector<ivec2> vp){    return std::any_of(std::begin(vp), std::end(vp), [&grid_positions = this->grid_positions](const auto &p)    {        return p.x >= grid_positions.right;    });}bool Game::is_touching_bottom_border(std::vector<ivec2> vp){    return std::any_of(std::begin(vp), std::end(vp), [&grid_positions = this->grid_positions](const auto &p)    {        return p.y <= grid_positions.bottom;    });}void Tetromino::unconditional_move_down(){    tile_grid_positions = translate_all(tile_grid_positions, {0, -1});    position_tiles();}void Tetromino::unconditional_move_right(){    tile_grid_positions = translate_all(tile_grid_positions, {1, 0});    position_tiles();}void Tetromino::unconditional_move_left(){    tile_grid_positions = translate_all(tile_grid_positions, {-1, 0});    position_tiles();}std::vector<ivec2> Tetromino::tile_piece_origin_positions(){    return translate_all(tile_grid_positions, -tile_grid_positions[0]);}bool Tetromino::rotate_srs_clockwise(){    auto new_orientation = (orientation + 1) % 4;    if (ttype == tetromino_type::O_PIECE)    {        orientation = new_orientation;        return true;    }    // Rotate 90 degrees all pieces, which for all pieces is the same    // as a true rotation except O and I which wobble because of their    // eccentric origin.    std::cout << "Attempting rotation " << orientation << "->" << new_orientation << std::endl;    std::cout << "Current Positions:\n";    auto new_tile_piece_origin_positions = pure_rotation(tile_piece_origin_positions(), 1);    std::cout << "Pure rotation Positions:\n";    for (auto &pos: new_tile_piece_origin_positions)    {        std::cout << "\t" << glm::to_string(pos) << "\n";    }    std::cout << std::endl;    // Calculate kick test values    auto od_c = tetromino_offset_data[std::make_pair(ttype, orientation)];    auto od_n = tetromino_offset_data[std::make_pair(ttype, new_orientation)];    std::vector<ivec2> kick_tests;    std::cout << "kick tests: ";    for (int i = 0; i < od_c.size(); ++i)    {        kick_tests.push_back(od_c[i] - od_n[i]);        std::cout << glm::to_string(kick_tests.back());    }    std::cout << std::endl;    // Perform kick tests and see if any valid positions arise    for (auto &kt: kick_tests)    {        auto test_position = translate_all(new_tile_piece_origin_positions, origin_grid_position() - kt);        std::cout << "TEST POSITIONS" << std::endl;        for (auto &pos: test_position)        {            std::cout << '\t' << glm::to_string(pos) << '\n';        }        if (parent->are_positions_valid(test_position))        {            std::cout << "KICK TEST SUCCESSFUL " << glm::to_string(kt) << std::endl;            tile_grid_positions = test_position;            orientation = new_orientation;            position_tiles();            return true;        }        std::cout << "KICK TEST FAILED " << glm::to_string(kt) << std::endl;    }    std::cout << "All kick tests failed. Aborting rotation" <<  std::endl;    // All kick tests failed cannot rotate    return false;}ivec2 Tetromino::origin_grid_position(){    return tile_grid_positions[0];}void Tetromino::position_tiles(){    int i = 0;    for (auto &tile: tetromino_tiles)    {        tile->set_position(tile_grid_positions[i++]);    }}void Animation::loop(int){    in_loop = true;    current_instance->animation_iteration();    glutPostRedisplay();    {        const std::scoped_lock<std::mutex> lock(loop_mutex);        in_loop = false;        if (should_loop)        {            glutTimerFunc(FRAME_PERIOD_MILLIS, &loop, 0);        }    }}AnimationRunnable *Animation::current_instance = nullptr;bool       Animation::in_loop = false, Animation::should_loop = false;std::mutex Animation::loop_mutex;Game *GAME = nullptr;class ShapeUtilities{    static void set_triangle_face_normal(const dvec3& a, const dvec3& b, const dvec3& c)    {        auto n = glm::cross((b - a), (c - a));        glNormal3d(n.x, n.y, n.z);    }    static void draw_triangle(const dvec3& a, const dvec3& b, const dvec3& c)    {        glBegin(GL_TRIANGLES);        set_triangle_face_normal(a, b, c);        glVertex3d(a.x, a.y, a.z);        glVertex3d(b.x, b.y, b.z);        glVertex3d(c.x, c.y, c.z);        glEnd();    }    static void draw_half_cube(float size)    {        std::vector<dvec3> p = {            { -size, size,  -size },            { size,  size,  -size },            { -size, -size, size  },            { size,  -size, size  },            { -size, -size, -size },            { size,  -size, -size },        };        draw_triangle(p[0], p[1], p[2]);        draw_triangle(p[1], p[3], p[2]);        draw_triangle(p[0], p[2], p[4]);        draw_triangle(p[1], p[5], p[3]);        draw_triangle(p[1], p[0], p[4]);        draw_triangle(p[1], p[4], p[5]);        draw_triangle(p[2], p[5], p[3]);        draw_triangle(p[2], p[4], p[5]);    }};static void display(){    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);    glPushMatrix();    gluLookAt(        0, 0, 1, // camera position        0, 0, 0, // looking-at point        0, 1, 0  // up vector        );    GAME->draw_all();    glPopMatrix();    glutSwapBuffers();}static void mouse(int button, int release, int mouse_x, int mouse_y){}static void keyboard(unsigned char key, int mouse_x, int mouse_y){    // std::cout << "PRESSED BUTTON " << key << std::endl;    bool needs_redisplay = true;    std::cout << "pressed '" << key << '\'' << std::endl;    switch (key)    {    case ASCII_ESCAPE:        exit(0);    case ' ':        if (GAME->animation_running())        {            GAME->stop_animation();        }        else        {            GAME->start_animation();        }        break;    default:        needs_redisplay = false;    }    if (needs_redisplay)    {        glutPostRedisplay();    }}static void special(int key, int mouse_x, int mouse_y){    bool needs_redisplay = true;    switch (key)    {    case GLUT_KEY_LEFT:        GAME->attempt_move_left();        break;    case GLUT_KEY_RIGHT:        GAME->attempt_move_right();        break;    case GLUT_KEY_UP:        GAME->attempt_rotate();        break;    case GLUT_KEY_DOWN:        GAME->attempt_move_down();        break;    default:        needs_redisplay = false;    }    if (needs_redisplay)    {        glutPostRedisplay();    }}void visibility(int state){    if (state == GLUT_VISIBLE)    {        GAME->start_animation();    }    else    {        GAME->start_animation();    }}bool init(){    glutInitWindowSize(WIN_WIDTH, WIN_HEIGHT);    glutInitWindowPosition(0, 0);    glutCreateWindow(WIN_TITLE.c_str());    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_DEPTH);    glutDisplayFunc(&display);    glutKeyboardFunc(&keyboard);    glutMouseFunc(&mouse);    glutSpecialFunc(&special);    glutVisibilityFunc(&visibility);    glutReshapeFunc(&reshape);    GLenum err = glewInit();    if (err != GLEW_OK)    {        std::cerr << "ERROR: GLEW failed to be initialized: " << glewGetErrorString(err) << std::endl;        return 0;    }    else    {        std::cout << "INFO: GLEW initialized successfully\n";    }    set_default_material(); // should be before initializing the game    GAME = new Game(GRID_X, GRID_Y, GRID_WIDTH, GRID_HEIGHT, GRID_UNIT_SIZE);    GAME->start_animation();    glLoadIdentity();    // glEnable(GL_CULL_FACE);    glEnable(GL_DEPTH_TEST);    glEnable(GL_NORMALIZE);    glClearColor(BG_COLOR[0], BG_COLOR[1], BG_COLOR[2], 1);    // Lighting    glShadeModel(GL_SMOOTH);    glLightfv(GL_LIGHT0, GL_POSITION, light_position);    glLightfv(GL_LIGHT0, GL_DIFFUSE, white_light);    glLightfv(GL_LIGHT0, GL_SPECULAR, white_light);    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);    glEnable(GL_LIGHTING);    glEnable(GL_LIGHT0);    return 1;}int main(int argc, char *argv[]){    glutInit(&argc, argv);    if (!init())    {        std::cout << "ERROR: Failed at initialization EXITING" << std::endl;        return 1;    }    glutMainLoop();    return 0;}